- 什么是 webgl
- 在哪里可以使用 webgl
- webgl 语法  或 使用方法
- 3D 与 webgl 关系
-  坐标系
- 坐标、齐次坐标
1. `(x,y,z)` 可以表示一个点，也可以表示一个向量
1. 只表示向量：`(x, y, z, 0)`
1. 只表示点：`(x, y, z, w)， w不为0`
```
 用n+1维坐标（x, y, z, w）表示n维坐标 (x, y, z) 的方式称为齐次坐标
```
1. 坐标 与 齐次坐标 转换
```
点(x,y,z)<==>(x,y,z,1);
向量(x,y,z)<==>(x,y,z,0)

```

- 向量、矩阵在 webgl 中有哪些用处 

- webgl 在哪里 使用了 列向量
```
shader 中
```

- 列向量、成右手坐标系（Z向外）

- 矩阵 在 webgl 中起了哪此作用
> 变换
1. 视图变换
1. 模型变换
1. 投影变换
1. 视见区变换


- 采用的 右手坐标系，列向量 的 3D 库 
1. WebGL
1. OpenGL
1. Threejs
> 因为 列向量， 所以 `rotateMat * moveMat * v`, 从右向左累加的 进行的


- 采用的 左手坐标系，行向量 的 3D 库
1. Direct X
1. Babylon


- 行向量，列向量，左手坐标系，右手坐标系，矩阵之间的联系
1. 行向量 与 列向量 的区别主要是 影响矩阵的组织方式
```
采用行向量表示坐标[x, y, z]时，矩阵则
[Xx, Xy, Xz]
[Yx, Yy, Yz]
[Zx, Zy, Zz]

采用列向量表示坐标(x/y/z)时，矩阵则
[ Xx, Yx, Zx]
[ Xy, Yy, Zy]
[ Xz, Yz, Zz]
```

1. 行左列右 规则
```
行左列右：向量与矩阵相乘，行向量就要在左侧，列向量在右侧

行向量乘法，矩阵左乘相当于行变换
[x, y, z] * [Xx, Xy, Xz]
            [Yx, Yy, Yz]
            [Zx, Zy, Zz]

列向量乘法，矩阵右乘相当于列变换
[ Xx, Yx, Zx] *    x
[ Xy, Yy, Zy]      y
[ Xz, Yz, Zz]      z            
```

1. 左右手坐标系与行列向量没有关系
1. 左右手坐标系会影响view矩阵和project矩阵的计算

- 旋转变换（最复杂）表示法：
1. 矩阵旋转
```
优点：
  旋转轴可以是任意向量；
缺点：
  旋转其实只需要知道一个向量+一个角度，一共4个值的信息，但矩阵法却使用了16个元素；
  而且在做乘法操作时也会增加计算量，造成了空间和时间上的一些浪费；
```
1. 欧拉旋转：一系列坐标轴（X|Y|Z）旋转的组合
```
优点：
  很容易理解，形象直观；
  表示更方便，只需要3个值（分别对应x、y、z轴的旋转角度）；但按我的理解，它还是转换到了3个3*3的矩阵做变换，效率不如四元数；
缺点：
  之前提到过这种方法是要按照一个固定的坐标轴的顺序旋转的，因此不同的顺序会造成不同的结果；
  会造成万向节锁（Gimbal Lock）的现象。这种现象的发生就是由于上述固定坐标轴旋转顺序造成的。理论上，欧拉旋转可以靠这种顺序让一个物体指到任何一个想要的方向，但如果在旋转中不幸让某些坐标轴重合了就会发生万向节锁，这时就会丢失一个方向上的旋转能力，也就是说在这种状态下我们无论怎么旋转（当然还是要原先的顺序）都不可能得到某些想要的旋转效果，除非我们打破原先的旋转顺序或者同时旋转3个坐标轴。这里有个视频可以直观的理解下；
  由于万向节锁的存在，欧拉旋转无法实现球面平滑插值；
```
1. 四元素旋转
```
每个分量的范围都在（-1，1）

优点：
  可以避免万向节锁现象；
  只需要一个4维的四元数就可以执行绕任意过原点的向量的旋转，方便快捷，在某些实现下比旋转矩阵效率更高；
  可以提供平滑插值；
缺点：
  比欧拉旋转稍微复杂了一点点，因为多了一个维度；
  理解更困难，不直观；
```

- 画图法计算矩阵相乘

- 矩阵数乘没有左乘和右乘概念
- 矩阵左乘与右乘与只与向量和矩阵
- 判断哪种坐标系，哪种向量存储
1. Z轴向外为右手坐标系，向内为左手坐标系
1. 向量在左为行向量，在右为列向量；图中横向表示为行向量，竖向表示为列向量

- lrtb透视投影矩阵为什么要进行平移
```
lrtb 形成的视锥体是不规则的，所以进行平移进行规则校正
```
- 转置矩阵的物理意义
```
一空间在另一空间的投影
```

- 从一个坐标系到另一个坐标系的转换

- 投影矩阵、视图矩阵、平移|缩放|旋转矩阵的关系

- 相机的运动与物体运动

- 按自己坐标进行移动
- 按世界坐标进行移动

- 各矩阵作用
1. 转置矩阵是指将行列互换之后的矩阵
1. 逆矩阵常用于法线变换
1. 仿射变换包含了主要包含了平移、旋转和缩放

1. 模型矩阵包含物体平移、缩放、旋转变换：将顶点从局部坐标系转化到世界坐标系中
1. 视图矩阵是相对于观察者位置的变换：将顶点从世界坐标系转化到视图坐标系下
```
如果将观察者视为一个模型，那么视图矩阵就是观察者的模型矩阵的逆矩阵。
观察者平移了(tx, ty, tz)，相当于整个世界平移了(-tx, -ty, -tz）。
观察者绕Z轴旋转了角度θ，相当于整个世界绕Z轴旋转了-θ度。
观察者在三个方向等比例缩小了s倍，相当于整个世界等比例放大了s倍。
```
1. 投影矩阵模拟是相机空间: 将视图坐标系中的顶点转化到平面上
```
观察者看到世界的一部分，上下左右前后都有边界，太近太远看不清，所以有near,far

```
> 本地坐标系(物体空间)--（模型矩阵）-->世界坐标系（世界空间）--（视图矩阵）-->视图坐标系（相机空间）--（投影矩阵）-->裁剪坐标系（裁剪空间）------------------> 设备空间，窗口空间
```
每个空间有自己的原点和坐标轴
```

- 旋转包含 
1. 世界坐标系的旋转 rotateOnWorld
1. 本地坐标系的旋转 rotate
1. 围绕任意轴旋转 rotateOnAxis

- canvas坐标系与WebGL坐标系不同，需要做坐标转换

- 多个矩阵变换时的相乘顺序：先 缩放 ，再 旋转 ，最后 平移 

- 法向量和光线入射向量的点积计算光照强度
```
点积：一个向量在另一向量的投影
叉积：同时垂直于两者的第三个向量
```

- 相机位置 与 视图矩阵的关系 
- 相机的运动（）

- 自转与公转
```
默认自转，公转可以添加空父物体，并空物体自转来实现其公转效果
```

- 制图、建模软件通常使用正交投影，这样不会因为投影而改变物体比例；而对于其他大多数应用，通常使用透视投影，因为这更接近人眼的观察效果

- 两坐标系间的转换推导
```
同一点，在两坐标系A,B的值分别是 （a1,a2, a3）和 (b1, b2, b3)
```

- [世界坐标系与相机坐标系转换](https://www.cnblogs.com/ghjnwk/p/10852264.html)
1. 坐标系的间转换就是旋转和平移
1. 相机默认与世界坐标系重合
1. 相机开始进行 平移或旋转后 到了当前位置
1. 相机的当前位置的模型矩阵就是相机运动的结果矩阵
1. 即从世界坐标经过相机模型矩阵到了当前位置：相机坐标系到世界坐标的转换是经过相机的模型矩阵
1. [世界坐标系到相机坐标系转换是经过相机的模型矩阵的逆矩阵](https://blog.csdn.net/RURUD/article/details/72823718?)

```
相机模型
先看看使用相机的主要步骤：

移动相机到拍摄位置，镜头对准某个方向(视图变换,view transform)
将拍摄对象一到场景中的某个位置(模型变换,model transform)
设置相机焦距或调整缩放比例(投影变换,projection transform)
对结果图像拉伸或者压缩，变换为需要的图片大小(视口变换,viewpoint transform)
```

- 跟随（保持一定的角度和距离）
- 两坐标系 调距，调姿势，
1. [三维空间任意一点绕任意轴线旋转](https://blog.csdn.net/maple_2014/article/details/104443928)
1. [三维重建：点绕特定轴旋转公式](https://blog.csdn.net/wishchin/article/details/80926037)

- 判断三维坐标系旋转正方向的简单方法
![判断三维坐标系旋转正方向的简单方法](./assets/left-right-hand-rule.jpg)
坐标系使用左手与右手的命名，有一个作用就是用来方便判断旋转的正方向，这就是左手法则和右手法则。例如对左手坐标系，确定一个旋转轴后，左手握住拳头，拇指指向旋转轴的正方向，四指弯曲的方向为旋转的正方向。相应地，右手坐标系就用右手来判定。确定了旋转的正方向后，在公式计算中就很容易知道是该使用正角度还是负角度了。

- 坐标系间的坐标转换
> 注意: 父子关系的中的模型矩阵，为相对矩阵，兄弟间的矩阵为，绝对矩阵

1. 父子节点 A > B, 即 B 是 A 的子节点，用 Ma 表示 A 的模型矩阵， mb 表示 B 的 模型矩阵，求 B 在世界坐标系矩阵 Mb ?
```
Mb = Ma * mb
```

1. 兄弟节点 A + B, 则 A, B 是兄弟节点， 用 Ma 表示 A 的模型矩阵， Mb 表示 B 的 模型矩阵，求 B 在 A 坐标系矩阵 mb ?
```
同上， Mb = Ma * mb
则，mb = Mb/Ma,
则，mb = Mb * Ma^-1
```

- 加入光照 与 不加入光照
1. 法线，法线矩阵
1. 环境光：放在最终颜色上的参数 `ambient * gl_FragColor` ,只与最终结果有关
1. 点光源：光源的位置是确定的
1. 平行光源：光的方向是固定的

- 多灯光
```js
  // 法向量归一化
    vec3 normal = normalize(v_normal);
    // 计算环境光反射颜色
    vec3 ambient = u_ambientColor * u_color.rgb;

    // 第一个光源:平行光
    vec3 lightDirection = normalize(u_lightPosition);
    // 计算法向量和光线的点积
    float cosTheta = max(dot(lightDirection, normal), 0.0);


    // 计算漫反射光的颜色
    vec3 diffuse = u_lightColor  * cosTheta * u_color.rgb;


    // 宾氏模型高光
    float shininess =100.0;
    vec3 specularColor =vec3(1.0,1.0,1.0);
    vec3 viewDirection = normalize(u_viewPosition-v_position);
    vec3 halfwayDir = normalize(lightDirection + viewDirection);
    float specularWeighting = pow(max(dot(normal, halfwayDir), 0.0), shininess);
    vec3 specular = specularColor.rgb * specularWeighting * step(cosTheta,0.0);

    // 第二个光源:点光源
    vec3 lightDirection2 = normalize(u_lightPosition2 - v_position.xyz);
    // 计算法向量和光线的点积
    float cosTheta2 = max(dot(lightDirection2, normal), 0.0);
    // 计算漫反射光的颜色
    vec3 diffuse2 = u_lightColor * cosTheta2 * u_color.rgb;

    // 冯氏模型高光
    float shininess2 =30.0;
    vec3 specularColor2 =vec3(1.0,1.0,1.0);
    vec3 reflectionDirection = reflect(-lightDirection2, normal);
    float specularWeighting2 = pow(max(dot(reflectionDirection, viewDirection), 0.0), shininess2);
    vec3 specular2 = specularColor2.rgb * specularWeighting2 * step(cosTheta,0.0);

    // 两个光源亮度相加
    gl_FragColor = vec4((ambient+diffuse+diffuse2)+specular+specular2,u_color.a);
```
- 着色器 与 片元器 交互
1. 