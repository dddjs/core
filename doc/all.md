- 什么是 webgl
- 在哪里可以使用 webgl
- webgl 语法  或 使用方法
- 3D 与 webgl 关系
-  坐标系
- 坐标、齐次坐标
1. `(x,y,z)` 可以表示一个点，也可以表示一个向量
1. 只表示向量：`(x, y, z, 0)`
1. 只表示点：`(x, y, z, w)， w不为0`
```
 用n+1维坐标（x, y, z, w）表示n维坐标 (x, y, z) 的方式称为齐次坐标
```
1. 坐标 与 齐次坐标 转换
```
点(x,y,z)<==>(x,y,z,1);
向量(x,y,z)<==>(x,y,z,0)

```

- 向量、矩阵在 webgl 中有哪些用处 

- webgl 在哪里 使用了 列向量
```
shader 中
```

- 列向量、成右手坐标系（Z向外）

- 矩阵 在 webgl 中起了哪此作用
> 变换
1. 视图变换
1. 模型变换
1. 投影变换
1. 视见区变换


- 采用的 右手坐标系，列向量 的 3D 库 
1. WebGL
1. OpenGL
1. Threejs
> 因为 列向量， 所以 `rotateMat * moveMat * v`, 从右向左累加的 进行的


- 采用的 左手坐标系，行向量 的 3D 库
1. Direct X
1. Babylon


- 行向量，列向量，左手坐标系，右手坐标系，矩阵之间的联系
1. 行向量 与 列向量 的区别主要是 影响矩阵的组织方式
```
采用行向量表示坐标[x, y, z]时，矩阵则
[Xx, Xy, Xz]
[Yx, Yy, Yz]
[Zx, Zy, Zz]

采用列向量表示坐标(x/y/z)时，矩阵则
[ Xx, Yx, Zx]
[ Xy, Yy, Zy]
[ Xz, Yz, Zz]
```

1. 行左列右 规则
```
行左列右：向量与矩阵相乘，行向量就要在左侧，列向量在右侧

行向量乘法，矩阵左乘相当于行变换
[x, y, z] * [Xx, Xy, Xz]
            [Yx, Yy, Yz]
            [Zx, Zy, Zz]

列向量乘法，矩阵右乘相当于列变换
[ Xx, Yx, Zx] *    x
[ Xy, Yy, Zy]      y
[ Xz, Yz, Zz]      z            
```

1. 左右手坐标系与行列向量没有关系
1. 左右手坐标系会影响view矩阵和project矩阵的计算

- 旋转变换（最复杂）表示法：
1. 矩阵旋转
```
优点：
  旋转轴可以是任意向量；
缺点：
  旋转其实只需要知道一个向量+一个角度，一共4个值的信息，但矩阵法却使用了16个元素；
  而且在做乘法操作时也会增加计算量，造成了空间和时间上的一些浪费；
```
1. 欧拉旋转：一系列坐标轴（X|Y|Z）旋转的组合
```
优点：
  很容易理解，形象直观；
  表示更方便，只需要3个值（分别对应x、y、z轴的旋转角度）；但按我的理解，它还是转换到了3个3*3的矩阵做变换，效率不如四元数；
缺点：
  之前提到过这种方法是要按照一个固定的坐标轴的顺序旋转的，因此不同的顺序会造成不同的结果；
  会造成万向节锁（Gimbal Lock）的现象。这种现象的发生就是由于上述固定坐标轴旋转顺序造成的。理论上，欧拉旋转可以靠这种顺序让一个物体指到任何一个想要的方向，但如果在旋转中不幸让某些坐标轴重合了就会发生万向节锁，这时就会丢失一个方向上的旋转能力，也就是说在这种状态下我们无论怎么旋转（当然还是要原先的顺序）都不可能得到某些想要的旋转效果，除非我们打破原先的旋转顺序或者同时旋转3个坐标轴。这里有个视频可以直观的理解下；
  由于万向节锁的存在，欧拉旋转无法实现球面平滑插值；
```
1. 四元素旋转
```
每个分量的范围都在（-1，1）

优点：
  可以避免万向节锁现象；
  只需要一个4维的四元数就可以执行绕任意过原点的向量的旋转，方便快捷，在某些实现下比旋转矩阵效率更高；
  可以提供平滑插值；
缺点：
  比欧拉旋转稍微复杂了一点点，因为多了一个维度；
  理解更困难，不直观；
```

- 画图法计算矩阵相乘

- 矩阵数乘没有左乘和右乘概念
- 矩阵左乘与右乘与只与向量和矩阵
- 判断哪种坐标系，哪种向量存储
1. Z轴向外为右手坐标系，向内为左手坐标系
1. 向量在左为行向量，在右为列向量；图中横向表示为行向量，竖向表示为列向量

- lrtb透视投影矩阵为什么要进行平移
```
lrtb 形成的视锥体是不规则的，所以进行平移进行规则校正
```
- 转置矩阵的物理意义
```
一空间在另一空间的投影
```

- 从一个坐标系到另一个坐标系的转换

- 投影矩阵、视图矩阵、平移|缩放|旋转矩阵的关系

- 相机的运动与物体运动

- 按自己坐标进行移动
- 按世界坐标进行移动

- 各矩阵作用
1. 转置矩阵是指将行列互换之后的矩阵
1. 逆矩阵常用于法线变换
1. 仿射变换包含了主要包含了平移、旋转和缩放

1. 模型矩阵包含物体平移、缩放、旋转变换：将顶点从局部坐标系转化到世界坐标系中
1. 视图矩阵是相对于观察者位置的变换：将顶点从世界坐标系转化到视图坐标系下
```
如果将观察者视为一个模型，那么视图矩阵就是观察者的模型矩阵的逆矩阵。
观察者平移了(tx, ty, tz)，相当于整个世界平移了(-tx, -ty, -tz）。
观察者绕Z轴旋转了角度θ，相当于整个世界绕Z轴旋转了-θ度。
观察者在三个方向等比例缩小了s倍，相当于整个世界等比例放大了s倍。
```
1. 投影矩阵模拟是相机空间: 将视图坐标系中的顶点转化到平面上
```
观察者看到世界的一部分，上下左右前后都有边界，太近太远看不清，所以有near,far

```
> 本地坐标系(物体空间)--（模型矩阵）-->世界坐标系（世界空间）--（视图矩阵）-->视图坐标系（相机空间）--（投影矩阵）-->裁剪坐标系（裁剪空间）------------------> 设备空间，窗口空间
```
每个空间有自己的原点和坐标轴
```

- 旋转包含 
1. 世界坐标系的旋转 rotateOnWorld
1. 本地坐标系的旋转 rotate
1. 围绕任意轴旋转 rotateOnAxis

- canvas坐标系与WebGL坐标系不同，需要做坐标转换

- 多个矩阵变换时的相乘顺序：先 缩放 ，再 旋转 ，最后 平移 

- 法向量和光线入射向量的点积计算光照强度
```
点积：一个向量在另一向量的投影
叉积：同时垂直于两者的第三个向量
```

- 相机位置 与 视图矩阵的关系 
- 相机的运动（）

- 自转与公转

- 制图、建模软件通常使用正交投影，这样不会因为投影而改变物体比例；而对于其他大多数应用，通常使用透视投影，因为这更接近人眼的观察效果